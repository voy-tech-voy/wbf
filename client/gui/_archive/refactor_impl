Theme Architecture Repair Plan
STOP / GO Verdict
Verdict: STOP

Do not proceed with expanding the current implementation. The current architecture suffers from critical scalability and maintenance issues that will compound as the application grows to 30k LOC.

Primary Reason: The Theme Propagation Mechanism is brittle. Currently, theme updates rely on manual recursion: 
MainWindow
 → CommandPanel → ChildWidget. Code like if hasattr(self.command_panel, 'update_theme') is a "code smell" that introduces tight coupling and makes it easy to miss widgets when adding new features.

1. Architecture Stress Test
A. Separation of Concerns (Theme.py vs Variables)
Status: PARTIAL FAIL
Issue: 
theme.py
 (Logic) and 
theme_variables.py
 (Data) are separated, which is good. However, 
theme_manager.py
 violates this by containing massive hardcoded QSS strings (Lines 126-389).
Risk: Visual styling logic is scattered. Changing a button's border radius requires checking 
theme.py
, 
theme_manager.py
 (QSS), and potentially 
custom_widgets.py
 (local overrides).
B. Signal Propagation (ThemeManager)
Status: CRITICAL FAIL
Issue: 
ThemeManager
 emits a signal theme_changed, but most widgets do not subscribe to it. Instead, 
MainWindow
 manually calls methods like 
update_theme()
 on specific children.
Consequence: Every new widget you create requires you to manually "wire up" its theme update logic in its parent. This is error-prone.
Fix: Widgets should either:
Subscribe to a global theme_manager signal, OR
Use a QPalette based approach where Qt handles basic updates, and only custom paints need signals.
C. Scalability
Status: LOW
Reason: The manual wiring requirement means the complexity of maintaining the theme system grows linearly with the number of widgets.
2. The "Real World" Fit
Primitives Analysis
Missing Capability: Dynamic Alpha / Opacity
Context: 
custom_widgets.py
 classes (e.g., 
GenericSegmentedControl
) currently use hardcoded rgba(255, 255, 255, 12) because the Theme system only returns HEX strings (e.g., #FFFFFF).
Failure: You cannot ask the Theme system for "Primary Opacity 50%". You are forced to hardcode values, breaking the single source of truth.
Custom Widgets Support
Grown/Animation: Supported locally in widgets but not standardized.
Noise/Gradients: Not natively supported by the Theme engine.
3. Naming & Consistency Audit
Semantic Naming: GOOD. surface_main, text_primary, border_dim are excellent semantic names.
Descriptive Naming: Avoid names like COLOR_RED (if any exist). Currently, 
error
, 
warning
 are used, which is correct.
Consistency: 
accent_turbo
 is a bit specific, but acceptable for this domain.
4. Gap List (Critical Features to Add)
Before proceeding, implement these features into the Core Theme Engine:

Color Manipulation Helpers (The "Missing primitives")

Add Theme.color_with_alpha(key: str, alpha: float) -> str
Returns rgba(r, g, b, a) string for use in QSS/Stylesheets.
QColor Object Access

Add Theme.to_qcolor(key: str) -> QColor
Vital for 
paintEvent
 drawing (like in your 
GPUIndicator
) so you don't have to manually parse hex strings.
Global Signal Bus

Make 
Theme
 (or 
ThemeManager
) a Singleton accessible globally.
Allow widgets to do ThemeManager.instance().theme_changed.connect(self.update_style) in their 
init
.
Centralized QSS Generator

Move the massive QSS strings from 
theme_manager.py
 into a specialized StyleSheetFactory or methods within 
Theme
 (e.g., Theme.get_scrollbar_style()). 
ThemeManager
 should only manage state, not define visual properties.
Proposed "Repair" Action Plan
Refactor 
Theme
 Class: Add color_as_qcolor and color_with_alpha methods.
Purge 
ThemeManager
: Move QSS generation logic to client/gui/styles/stylesheets.py (new file) or 
theme.py
.
Fix Propagation: Update 
MainWindow
 to stop manually calling 
update_theme
. Instead, have 
ThemedCheckBox
 and others connect to ThemeManager.theme_changed signal upon initialization.